import { ADDR_MODE } from "../emulator/utility/utility"

interface OpCode {
  name: string
  mode: ADDR_MODE
}

export const opCodes = new Array<OpCode>(256)
export const opTable: { [key: string]: number[] } = {}

const PCODE = (name: string, mode: ADDR_MODE, pcode: number) => {
  console.assert(!opCodes[pcode], "Duplicate instruction: " + name + " mode=" + mode)
  opCodes[pcode] = {name: name, mode: mode}
  if (!opTable[name]) opTable[name] = []
  opTable[name][mode] = pcode
}

PCODE('ADC', ADDR_MODE.IMM, 0x69)
PCODE('ADC', ADDR_MODE.ZP_REL, 0x65)
PCODE('ADC', ADDR_MODE.ZP_X, 0x75)
PCODE('ADC', ADDR_MODE.ABS, 0x6D)
PCODE('ADC', ADDR_MODE.ABS_X, 0x7D)
PCODE('ADC', ADDR_MODE.ABS_Y, 0x79)
PCODE('ADC', ADDR_MODE.IND_X, 0x61)
PCODE('ADC', ADDR_MODE.IND_Y, 0x71)
PCODE('ADC', ADDR_MODE.IND, 0x72)
PCODE('AND', ADDR_MODE.IMM, 0x29)
PCODE('AND', ADDR_MODE.ZP_REL, 0x25)
PCODE('AND', ADDR_MODE.ZP_X, 0x35)
PCODE('AND', ADDR_MODE.ABS, 0x2D)
PCODE('AND', ADDR_MODE.ABS_X, 0x3D)
PCODE('AND', ADDR_MODE.ABS_Y, 0x39)
PCODE('AND', ADDR_MODE.IND_X, 0x21)
PCODE('AND', ADDR_MODE.IND_Y, 0x31)
PCODE('AND', ADDR_MODE.IND, 0x32)
PCODE('ASL', ADDR_MODE.IMPLIED, 0x0A)
PCODE('ASL', ADDR_MODE.ZP_REL, 0x06)
PCODE('ASL', ADDR_MODE.ZP_X, 0x16)
PCODE('ASL', ADDR_MODE.ABS, 0x0E)
PCODE('ASL', ADDR_MODE.ABS_X, 0x1E)
PCODE('BCC', ADDR_MODE.ZP_REL, 0x90)
PCODE('BCS', ADDR_MODE.ZP_REL, 0xB0)
PCODE('BEQ', ADDR_MODE.ZP_REL, 0xF0)
PCODE('BMI', ADDR_MODE.ZP_REL, 0x30)
PCODE('BNE', ADDR_MODE.ZP_REL, 0xD0)
PCODE('BPL', ADDR_MODE.ZP_REL, 0x10)
PCODE('BVC', ADDR_MODE.ZP_REL, 0x50)
PCODE('BVS', ADDR_MODE.ZP_REL, 0x70)
PCODE('BRA', ADDR_MODE.ZP_REL, 0x80)
PCODE('BIT', ADDR_MODE.ZP_REL, 0x24)
PCODE('BIT', ADDR_MODE.ABS, 0x2C)
PCODE('BIT', ADDR_MODE.IMM, 0x89)
PCODE('BIT', ADDR_MODE.ZP_X, 0x34)
PCODE('BIT', ADDR_MODE.ABS_X, 0x3C)
PCODE('BRK', ADDR_MODE.IMPLIED, 0x00)
PCODE('CLC', ADDR_MODE.IMPLIED, 0x18)
PCODE('CLD', ADDR_MODE.IMPLIED, 0xD8)
PCODE('CLI', ADDR_MODE.IMPLIED, 0x58)
PCODE('CLV', ADDR_MODE.IMPLIED, 0xB8)
PCODE('CMP', ADDR_MODE.IMM, 0xC9)
PCODE('CMP', ADDR_MODE.ZP_REL, 0xC5)
PCODE('CMP', ADDR_MODE.ZP_X, 0xD5)
PCODE('CMP', ADDR_MODE.ABS, 0xCD)
PCODE('CMP', ADDR_MODE.ABS_X, 0xDD)
PCODE('CMP', ADDR_MODE.ABS_Y, 0xD9)
PCODE('CMP', ADDR_MODE.IND_X, 0xC1)
PCODE('CMP', ADDR_MODE.IND_Y, 0xD1)
PCODE('CMP', ADDR_MODE.IND, 0xD2)
PCODE('CPX', ADDR_MODE.IMM, 0xE0)
PCODE('CPX', ADDR_MODE.ZP_REL, 0xE4)
PCODE('CPX', ADDR_MODE.ABS, 0xEC)
PCODE('CPY', ADDR_MODE.IMM, 0xC0)
PCODE('CPY', ADDR_MODE.ZP_REL, 0xC4)
PCODE('CPY', ADDR_MODE.ABS, 0xCC)
PCODE('DEC', ADDR_MODE.IMPLIED, 0x3A)
PCODE('DEC', ADDR_MODE.ZP_REL, 0xC6)
PCODE('DEC', ADDR_MODE.ZP_X, 0xD6)
PCODE('DEC', ADDR_MODE.ABS, 0xCE)
PCODE('DEC', ADDR_MODE.ABS_X, 0xDE)
PCODE('DEX', ADDR_MODE.IMPLIED, 0xCA)
PCODE('DEY', ADDR_MODE.IMPLIED, 0x88)
PCODE('EOR', ADDR_MODE.IMM, 0x49)
PCODE('EOR', ADDR_MODE.ZP_REL, 0x45)
PCODE('EOR', ADDR_MODE.ZP_X, 0x55)
PCODE('EOR', ADDR_MODE.ABS, 0x4D)
PCODE('EOR', ADDR_MODE.ABS_X, 0x5D)
PCODE('EOR', ADDR_MODE.ABS_Y, 0x59)
PCODE('EOR', ADDR_MODE.IND_X, 0x41)
PCODE('EOR', ADDR_MODE.IND_Y, 0x51)
PCODE('EOR', ADDR_MODE.IND, 0x52)
PCODE('INC', ADDR_MODE.IMPLIED, 0x1A)
PCODE('INC', ADDR_MODE.ZP_REL, 0xE6)
PCODE('INC', ADDR_MODE.ZP_X, 0xF6)
PCODE('INC', ADDR_MODE.ABS, 0xEE)
PCODE('INC', ADDR_MODE.ABS_X, 0xFE)
PCODE('INX', ADDR_MODE.IMPLIED, 0xE8)
PCODE('INY', ADDR_MODE.IMPLIED, 0xC8)
PCODE('JMP', ADDR_MODE.ABS, 0x4C)
PCODE('JMP', ADDR_MODE.IND, 0x6C)
PCODE('JMP', ADDR_MODE.IND_X, 0x7C)
PCODE('JSR', ADDR_MODE.ABS, 0x20)
PCODE('LDA', ADDR_MODE.IMM, 0xA9)
PCODE('LDA', ADDR_MODE.ZP_REL, 0xA5)
PCODE('LDA', ADDR_MODE.ZP_X, 0xB5)
PCODE('LDA', ADDR_MODE.ABS, 0xAD)
PCODE('LDA', ADDR_MODE.ABS_X, 0xBD)
PCODE('LDA', ADDR_MODE.ABS_Y, 0xB9)
PCODE('LDA', ADDR_MODE.IND_X, 0xA1)
PCODE('LDA', ADDR_MODE.IND_Y, 0xB1)
PCODE('LDA', ADDR_MODE.IND, 0xB2)
PCODE('LDX', ADDR_MODE.IMM, 0xA2)
PCODE('LDX', ADDR_MODE.ZP_REL, 0xA6)
PCODE('LDX', ADDR_MODE.ZP_Y, 0xB6)
PCODE('LDX', ADDR_MODE.ABS, 0xAE)
PCODE('LDX', ADDR_MODE.ABS_Y, 0xBE)
PCODE('LDY', ADDR_MODE.IMM, 0xA0)
PCODE('LDY', ADDR_MODE.ZP_REL, 0xA4)
PCODE('LDY', ADDR_MODE.ZP_X, 0xB4)
PCODE('LDY', ADDR_MODE.ABS, 0xAC)
PCODE('LDY', ADDR_MODE.ABS_X, 0xBC)
PCODE('LSR', ADDR_MODE.IMPLIED, 0x4A)
PCODE('LSR', ADDR_MODE.ZP_REL, 0x46)
PCODE('LSR', ADDR_MODE.ZP_X, 0x56)
PCODE('LSR', ADDR_MODE.ABS, 0x4E)
PCODE('LSR', ADDR_MODE.ABS_X, 0x5E)
PCODE('NOP', ADDR_MODE.IMPLIED, 0xEA)
PCODE('ORA', ADDR_MODE.IMM, 0x09)
PCODE('ORA', ADDR_MODE.ZP_REL, 0x05)
PCODE('ORA', ADDR_MODE.ZP_X, 0x15)
PCODE('ORA', ADDR_MODE.ABS, 0x0D)
PCODE('ORA', ADDR_MODE.ABS_X, 0x1D)
PCODE('ORA', ADDR_MODE.ABS_Y, 0x19)
PCODE('ORA', ADDR_MODE.IND_X, 0x01)
PCODE('ORA', ADDR_MODE.IND_Y, 0x11)
PCODE('ORA', ADDR_MODE.IND, 0x12)
PCODE('PHA', ADDR_MODE.IMPLIED, 0x48)
PCODE('PHP', ADDR_MODE.IMPLIED, 0x08)
PCODE('PHX', ADDR_MODE.IMPLIED, 0xDA)
PCODE('PHY', ADDR_MODE.IMPLIED, 0x5A)
PCODE('PLA', ADDR_MODE.IMPLIED, 0x68)
PCODE('PLP', ADDR_MODE.IMPLIED, 0x28)
PCODE('PLX', ADDR_MODE.IMPLIED, 0xFA)
PCODE('PLY', ADDR_MODE.IMPLIED, 0x7A)
PCODE('ROL', ADDR_MODE.IMPLIED, 0x2A)
PCODE('ROL', ADDR_MODE.ZP_REL, 0x26)
PCODE('ROL', ADDR_MODE.ZP_X, 0x36)
PCODE('ROL', ADDR_MODE.ABS, 0x2E)
PCODE('ROL', ADDR_MODE.ABS_X, 0x3E)
PCODE('ROR', ADDR_MODE.IMPLIED, 0x6A)
PCODE('ROR', ADDR_MODE.ZP_REL, 0x66)
PCODE('ROR', ADDR_MODE.ZP_X, 0x76)
PCODE('ROR', ADDR_MODE.ABS, 0x6E)
PCODE('ROR', ADDR_MODE.ABS_X, 0x7E)
PCODE('RTI', ADDR_MODE.IMPLIED, 0x40)
PCODE('RTS', ADDR_MODE.IMPLIED, 0x60)
PCODE('SBC', ADDR_MODE.IMM, 0xE9)
PCODE('SBC', ADDR_MODE.ZP_REL, 0xE5)
PCODE('SBC', ADDR_MODE.ZP_X, 0xF5)
PCODE('SBC', ADDR_MODE.ABS, 0xED)
PCODE('SBC', ADDR_MODE.ABS_X, 0xFD)
PCODE('SBC', ADDR_MODE.ABS_Y, 0xF9)
PCODE('SBC', ADDR_MODE.IND_X, 0xE1)
PCODE('SBC', ADDR_MODE.IND_Y, 0xF1)
PCODE('SBC', ADDR_MODE.IND, 0xF2)
PCODE('SEC', ADDR_MODE.IMPLIED, 0x38)
PCODE('SED', ADDR_MODE.IMPLIED, 0xF8)
PCODE('SEI', ADDR_MODE.IMPLIED, 0x78)
PCODE('STA', ADDR_MODE.ZP_REL, 0x85)
PCODE('STA', ADDR_MODE.ZP_X, 0x95)
PCODE('STA', ADDR_MODE.ABS, 0x8D)
PCODE('STA', ADDR_MODE.ABS_X, 0x9D)
PCODE('STA', ADDR_MODE.ABS_Y, 0x99)
PCODE('STA', ADDR_MODE.IND_X, 0x81)
PCODE('STA', ADDR_MODE.IND_Y, 0x91)
PCODE('STA', ADDR_MODE.IND, 0x92)
PCODE('STX', ADDR_MODE.ZP_REL, 0x86)
PCODE('STX', ADDR_MODE.ZP_Y, 0x96)
PCODE('STX', ADDR_MODE.ABS, 0x8E)
PCODE('STY', ADDR_MODE.ZP_REL, 0x84)
PCODE('STY', ADDR_MODE.ZP_X, 0x94)
PCODE('STY', ADDR_MODE.ABS, 0x8C)
PCODE('STZ', ADDR_MODE.ZP_REL, 0x64)
PCODE('STZ', ADDR_MODE.ZP_X, 0x74)
PCODE('STZ', ADDR_MODE.ABS, 0x9C)
PCODE('STZ', ADDR_MODE.ABS_X, 0x9E)
PCODE('TAX', ADDR_MODE.IMPLIED, 0xAA)
PCODE('TAY', ADDR_MODE.IMPLIED, 0xA8)
PCODE('TSX', ADDR_MODE.IMPLIED, 0xBA)
PCODE('TXA', ADDR_MODE.IMPLIED, 0x8A)
PCODE('TXS', ADDR_MODE.IMPLIED, 0x9A)
PCODE('TYA', ADDR_MODE.IMPLIED, 0x98)
PCODE('TRB', ADDR_MODE.ZP_REL, 0x14)
PCODE('TRB', ADDR_MODE.ABS, 0x1C)
PCODE('TSB', ADDR_MODE.ZP_REL, 0x04)
PCODE('TSB', ADDR_MODE.ABS, 0x0C)
const twoByteNops = [0x02, 0x22, 0x42, 0x62, 0x82, 0xC2, 0xE2]
const nopUndoc = '???'
twoByteNops.forEach(instr => {
  PCODE(nopUndoc, ADDR_MODE.IMPLIED, instr)
});
for (let i = 0; i <= 15; i++) {
  PCODE(nopUndoc, ADDR_MODE.IMPLIED, 3 + 16 * i)
  PCODE(nopUndoc, ADDR_MODE.IMPLIED, 7 + 16 * i)
  PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0xB + 16 * i)
  PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0xF + 16 * i)
}
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0x44)
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0x54)
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0xD4)
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0xF4)
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0x5C)
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0xDC)
PCODE(nopUndoc, ADDR_MODE.IMPLIED, 0xFC)

// Fill the rest of the 65c02 with BRK instructions. This avoids needing
// to do a check in processInstruction, and also breaks on a bad op code.
for (let i = 0; i < 256; i++) {
  if (!opCodes[i]) {
    console.log("ERROR: OPCODE " + i.toString(16) + " should be implemented")
  }
}

export const opCodeNames = Object.keys(opTable)
